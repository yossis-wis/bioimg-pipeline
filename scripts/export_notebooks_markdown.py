#!/usr/bin/env python3
"""export_notebooks_markdown.py

Generate GitHub-friendly Markdown mirrors of our Jupytext percent-format notebooks.

Why this exists
---------------
The canonical notebooks in this repo are stored as plain-text Python files in
`notebooks/*.py` (Jupytext percent format). This is great for diffs/reviews and
for running notebooks in VS Code/JupyterLab, but GitHub does not render the
Markdown cells inside `.py` files.

This script extracts Markdown + code cells from the percent-format notebooks and
writes a readable `.md` mirror under `docs/notebooks_md/` (no cell outputs).

Design goals
------------
- No dependency on `jupytext` at runtime (parses the percent format directly).
- Deterministic output (stable diffs across OSes).
- Code cells are wrapped in `<details>` so the narrative reads like a doc.

Usage
-----
Write mirrors for the documentation-style optics notebooks (06–12):

    python scripts/export_notebooks_markdown.py

Write mirrors for *all* notebooks in `notebooks/`:

    python scripts/export_notebooks_markdown.py --all

Verify mirrors are up to date (no writes, CI-friendly):

    python scripts/export_notebooks_markdown.py --check

Export specific notebooks:

    python scripts/export_notebooks_markdown.py notebooks/12_mmf_wide_linewidth_stepindex_slab_geometric_optics.py
"""

from __future__ import annotations

import argparse
import re
import sys
from dataclasses import dataclass
from pathlib import Path


REPO_ROOT = Path(__file__).resolve().parents[1]
DEFAULT_OUT_DIR = REPO_ROOT / "docs" / "notebooks_md"

# Default export set: the doc-style optics notebooks (06–13).
DEFAULT_NOTEBOOK_RE = re.compile(r"^(0[6-9]|1[0-3])_.*\.py$")

MARKDOWN_CELL_MARKER_RE = re.compile(r"^# %%\s*\[markdown\]\s*$")


@dataclass(frozen=True)
class Cell:
    kind: str  # "markdown" | "code"
    lines: list[str]


def parse_percent_format(py_text: str) -> list[Cell]:
    """Parse a Jupytext percent-format `.py` into ordered cells."""
    lines = py_text.splitlines()
    cells: list[Cell] = []

    started = False
    cur_kind: str | None = None
    cur_lines: list[str] = []

    for line in lines:
        if line.startswith("# %%"):
            # Flush previous cell
            if started and cur_kind is not None:
                while cur_lines and cur_lines[-1].strip() == "":
                    cur_lines.pop()
                cells.append(Cell(cur_kind, cur_lines))
                cur_lines = []
            started = True
            cur_kind = "markdown" if MARKDOWN_CELL_MARKER_RE.match(line) else "code"
            continue

        if not started:
            # Skip the Jupytext header/preamble.
            continue

        cur_lines.append(line)

    if started and cur_kind is not None:
        while cur_lines and cur_lines[-1].strip() == "":
            cur_lines.pop()
        cells.append(Cell(cur_kind, cur_lines))

    return cells


def render_cells_to_markdown(cells: list[Cell], *, src_rel: str) -> str:
    """Render parsed cells to a Markdown mirror (no outputs)."""
    out: list[str] = []
    out.extend(
        [
            "<!--",
            "AUTO-GENERATED FILE. DO NOT EDIT DIRECTLY.",
            f"Source: {src_rel}",
            "Generated by: scripts/export_notebooks_markdown.py",
            "-->",
            "",
        ]
    )

    code_cell_idx = 0

    for cell in cells:
        if cell.kind == "markdown":
            for ln in cell.lines:
                if ln.startswith("#"):
                    s = ln[1:]
                    if s.startswith(" "):
                        s = s[1:]
                    out.append(s)
                else:
                    # Defensive: Jupytext markdown cells should be comment lines,
                    # but keep unexpected content rather than silently dropping it.
                    out.append(ln)
            out.append("")
            continue

        # Code cell
        code = "\n".join(cell.lines).rstrip()
        if code.strip() == "":
            continue

        code_cell_idx += 1
        out.append("<details>")
        out.append(f"<summary>Code cell {code_cell_idx}</summary>")
        out.append("")
        out.append("```python")
        out.extend(cell.lines)
        out.append("```")
        out.append("")
        out.append("</details>")
        out.append("")

    return "\n".join(out).rstrip() + "\n"


def iter_default_notebooks(nb_dir: Path) -> list[Path]:
    return sorted(p for p in nb_dir.glob("*.py") if p.is_file() and DEFAULT_NOTEBOOK_RE.match(p.name))


def iter_all_notebooks(nb_dir: Path) -> list[Path]:
    return sorted(p for p in nb_dir.glob("*.py") if p.is_file())


def generate_one(src_py: Path, out_dir: Path) -> tuple[Path, str]:
    text = src_py.read_text(encoding="utf-8", errors="replace")
    cells = parse_percent_format(text)
    try:
        src_rel = src_py.resolve().relative_to(REPO_ROOT).as_posix()
    except Exception:
        src_rel = src_py.as_posix()
    md = render_cells_to_markdown(cells, src_rel=src_rel)
    out_path = out_dir / (src_py.stem + ".md")
    return out_path, md


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "notebooks",
        nargs="*",
        help="Optional notebook paths (defaults to optics notebooks 06–12).",
    )
    ap.add_argument(
        "--out-dir",
        default=str(DEFAULT_OUT_DIR),
        help="Output directory for Markdown mirrors (default: docs/notebooks_md).",
    )
    ap.add_argument(
        "--all",
        action="store_true",
        help="Export all notebooks in notebooks/ (ignored if explicit notebook paths are provided).",
    )
    ap.add_argument(
        "--check",
        action="store_true",
        help="Verify outputs are up to date; do not write files. Exit non-zero on mismatch.",
    )
    args = ap.parse_args()

    nb_dir = REPO_ROOT / "notebooks"
    if not nb_dir.exists():
        print("ERROR: notebooks/ directory not found.", file=sys.stderr)
        return 2

    out_dir = Path(args.out_dir)
    if not out_dir.is_absolute():
        out_dir = (REPO_ROOT / out_dir).resolve()

    if args.notebooks:
        src_paths = [Path(p) for p in args.notebooks]
    else:
        src_paths = iter_all_notebooks(nb_dir) if args.all else iter_default_notebooks(nb_dir)

    # Normalize to repo-root-relative paths when possible (helps portability).
    normalized: list[Path] = []
    for p in src_paths:
        p2 = p
        if not p2.is_absolute():
            p2 = (REPO_ROOT / p2).resolve()
        if not p2.exists():
            print(f"ERROR: notebook not found: {p}", file=sys.stderr)
            return 2
        normalized.append(p2)

    mismatches: list[str] = []

    if not args.check:
        out_dir.mkdir(parents=True, exist_ok=True)

    for src_py in normalized:
        out_path, md = generate_one(src_py, out_dir)

        if args.check:
            if not out_path.exists():
                mismatches.append(f"missing: {out_path.as_posix()}")
                continue
            cur = out_path.read_text(encoding="utf-8", errors="replace")
            if cur != md:
                mismatches.append(f"differs: {out_path.as_posix()}")
            continue

        out_path.write_text(md, encoding="utf-8")

    if mismatches:
        print("Notebook Markdown mirrors are not up to date:", file=sys.stderr)
        for m in mismatches:
            print(f"  - {m}", file=sys.stderr)
        print("", file=sys.stderr)
        print("Run:", file=sys.stderr)
        print("  python scripts/export_notebooks_markdown.py", file=sys.stderr)
        return 1

    if args.check:
        print("OK: notebook Markdown mirrors are up to date.")
    else:
        print(f"OK: wrote Markdown mirrors to {out_dir.as_posix()}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
