from __future__ import annotations

"""Excitation-field simulation kernels (pure computation).

This module exists to connect *illumination design* choices to downstream spot detection
without pulling in microscope-specific filesystem logic.

Core idea
---------
We synthesize an excitation intensity field in the sample plane for a square ROI and a finite
illumination NA:

- The square ROI is set by a *field stop* (field-conjugate plane).
- Edge roll-off + speckle grain statistics are set by an effective illumination NA,
  \(\mathrm{NA}_{\mathrm{illum}}\), via a circular pupil low-pass.

The simulation is scalar and 2D. It is intended for *design intuition*, not a full physical model.
"""

from dataclasses import dataclass
from typing import Optional

import numpy as np


@dataclass(frozen=True)
class ExcitationSimMeta:
    """Metadata returned alongside a simulated excitation field."""

    lambda_um: float
    dx_um: float
    roi_um: float
    na_illum: float
    exposure_s: float
    scrambler_hz: float
    n_time: int
    n_src: int
    n_eff: int


def _fftfreq_um(n: int, dx_um: float) -> np.ndarray:
    """FFT frequency coordinates in cycles/µm."""
    return np.fft.fftfreq(n, d=dx_um)


def make_circular_pupil(
    n: int,
    dx_um: float,
    lambda_um: float,
    na_illum: float,
) -> np.ndarray:
    """Return an unshifted circular coherent transfer function (CTF).

    The coherent cutoff (cycles/µm) is approximated as:

    \[
        f_c = \frac{\mathrm{NA}_{\mathrm{illum}}}{\lambda}.
    \]

    Parameters
    ----------
    n:
        Grid size (assumes square n×n).
    dx_um:
        Sample-plane pixel pitch (µm/px).
    lambda_um:
        Wavelength (µm).
    na_illum:
        Effective illumination NA at the sample.

    Returns
    -------
    pupil:
        Boolean mask (n, n) in FFT ordering (compatible with np.fft.fft2 output).
    """
    if lambda_um <= 0:
        raise ValueError("lambda_um must be > 0")
    if na_illum <= 0:
        raise ValueError("na_illum must be > 0")

    fx = _fftfreq_um(n, dx_um)
    fy = fx
    fx2, fy2 = np.meshgrid(fx, fy, indexing="xy")
    fc = na_illum / lambda_um
    return (fx2 * fx2 + fy2 * fy2) <= (fc * fc)


def square_roi_mask(
    n: int,
    dx_um: float,
    roi_um: float,
    *,
    center: Optional[tuple[float, float]] = None,
) -> np.ndarray:
    """Square ROI mask in the sample plane (boolean)."""
    if roi_um <= 0:
        raise ValueError("roi_um must be > 0")
    if center is None:
        cx_um = 0.0
        cy_um = 0.0
    else:
        cx_um, cy_um = center

    coords_um = (np.arange(n) - n // 2) * dx_um
    x_um, y_um = np.meshgrid(coords_um - cx_um, coords_um - cy_um, indexing="xy")
    half = 0.5 * roi_um
    return (np.abs(x_um) <= half) & (np.abs(y_um) <= half)


def simulate_excitation_speckle_field(
    *,
    n: int,
    dx_um: float,
    roi_um: float,
    lambda_um: float,
    na_illum: float,
    exposure_s: float,
    scrambler_hz: float,
    n_src: int = 1,
    seed: Optional[int] = 0,
) -> tuple[np.ndarray, ExcitationSimMeta]:
    """Simulate a time-averaged excitation intensity field for a square ROI.

    We model a *coherent* field passing through a square field stop and a circular pupil low-pass
    (finite illumination NA). Speckle is generated by drawing independent complex Gaussian fields
    (random phase/amplitude) and averaging their intensities.

    Independence model
    ------------------
    The effective number of independent realizations is approximated as:

    \[
        N_{\mathrm{eff}} \approx N_{\mathrm{time}}\,N_{\mathrm{src}},\qquad
        N_{\mathrm{time}} = \max\{1,\,\mathrm{round}(f_{\mathrm{scr}}\,\tau)\}.
    \]

    This is a pragmatic proxy for:
    - time decorrelation from a scrambler at frequency \(f_{\mathrm{scr}}\),
    - additional incoherent diversity from multiple spatial/spectral modes (\(N_{\mathrm{src}}\)).

    Parameters
    ----------
    n:
        Grid size (n×n).
    dx_um:
        Pixel pitch in the sample plane (µm/px).
    roi_um:
        Side length of square ROI at the sample (µm).
    lambda_um:
        Excitation wavelength (µm).
    na_illum:
        Effective illumination NA at the sample.
    exposure_s:
        Exposure time (s).
    scrambler_hz:
        Scrambler decorrelation rate (Hz). (If 0, we clamp to 1 realization.)
    n_src:
        Extra incoherent diversity factor (>=1).
    seed:
        RNG seed for reproducibility. Use None for nondeterministic.

    Returns
    -------
    (I, meta)
        I:
            Float64 array (n, n) of intensity (arbitrary units).
        meta:
            ExcitationSimMeta with bookkeeping.
    """
    if n <= 0:
        raise ValueError("n must be > 0")
    if dx_um <= 0:
        raise ValueError("dx_um must be > 0")
    if exposure_s <= 0:
        raise ValueError("exposure_s must be > 0")
    if n_src < 1:
        raise ValueError("n_src must be >= 1")

    rng = np.random.default_rng(seed)

    n_time = max(1, int(np.round(max(0.0, scrambler_hz) * exposure_s)))
    n_eff = n_time * int(n_src)

    pupil = make_circular_pupil(n=n, dx_um=dx_um, lambda_um=lambda_um, na_illum=na_illum)
    mask = square_roi_mask(n=n, dx_um=dx_um, roi_um=roi_um).astype(np.float64)

    I_acc = np.zeros((n, n), dtype=np.float64)

    for _ in range(n_eff):
        u = rng.standard_normal((n, n)) + 1j * rng.standard_normal((n, n))
        u = u * mask  # field stop (amplitude)
        U = np.fft.fft2(u)
        U *= pupil
        u_img = np.fft.ifft2(U)
        I_acc += (u_img.real * u_img.real + u_img.imag * u_img.imag)

    I = I_acc / float(n_eff)

    meta = ExcitationSimMeta(
        lambda_um=float(lambda_um),
        dx_um=float(dx_um),
        roi_um=float(roi_um),
        na_illum=float(na_illum),
        exposure_s=float(exposure_s),
        scrambler_hz=float(scrambler_hz),
        n_time=int(n_time),
        n_src=int(n_src),
        n_eff=int(n_eff),
    )

    return I, meta
